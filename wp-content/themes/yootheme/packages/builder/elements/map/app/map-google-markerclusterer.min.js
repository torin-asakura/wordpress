/*! YOOtheme Pro v4.4.15 | https://yootheme.com */

function kt(E){return E&&E.__esModule&&Object.prototype.hasOwnProperty.call(E,"default")?E.default:E}var O={exports:{}},wt=O.exports,lt;function yt(){return lt||(lt=1,function(E,ct){(function(m,C){C(ct)})(wt,function(m){function C(o,t){var e={};for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&t.indexOf(r)<0&&(e[r]=o[r]);if(o!=null&&typeof Object.getOwnPropertySymbols=="function"){var s=0;for(r=Object.getOwnPropertySymbols(o);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(o,r[s])&&(e[r[s]]=o[r[s]])}return e}class f{static isAdvancedMarkerAvailable(t){return google.maps.marker&&t.getMapCapabilities().isAdvancedMarkersAvailable===!0}static isAdvancedMarker(t){return google.maps.marker&&t instanceof google.maps.marker.AdvancedMarkerElement}static setMap(t,e){this.isAdvancedMarker(t)?t.map=e:t.setMap(e)}static getPosition(t){if(this.isAdvancedMarker(t)){if(t.position){if(t.position instanceof google.maps.LatLng)return t.position;if(t.position.lat&&t.position.lng)return new google.maps.LatLng(t.position.lat,t.position.lng)}return new google.maps.LatLng(null)}return t.getPosition()}static getVisible(t){return!!this.isAdvancedMarker(t)||t.getVisible()}}class P{constructor(t){let{markers:e,position:r}=t;this.markers=e,r&&(r instanceof google.maps.LatLng?this._position=r:this._position=new google.maps.LatLng(r))}get bounds(){if(this.markers.length===0&&!this._position)return;const t=new google.maps.LatLngBounds(this._position,this._position);for(const e of this.markers)t.extend(f.getPosition(e));return t}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter(t=>f.getVisible(t)).length}push(t){this.markers.push(t)}delete(){this.marker&&(f.setMap(this.marker,null),this.marker=void 0),this.markers.length=0}}const S=(o,t,e,r)=>{const s=Z(o.getBounds(),t,r);return e.filter(n=>s.contains(f.getPosition(n)))},Z=(o,t,e)=>{const{northEast:r,southWest:s}=ut(o,t),n=W({northEast:r,southWest:s},e);return q(n,t)},z=(o,t,e)=>{const r=Z(o,t,e),s=r.getNorthEast(),n=r.getSouthWest();return[n.lng(),n.lat(),s.lng(),s.lat()]},G=(o,t)=>{const e=(t.lat-o.lat)*Math.PI/180,r=(t.lng-o.lng)*Math.PI/180,s=Math.sin(e/2),n=Math.sin(r/2),a=s*s+Math.cos(o.lat*Math.PI/180)*Math.cos(t.lat*Math.PI/180)*n*n;return 6371*(2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)))},ut=(o,t)=>({northEast:t.fromLatLngToDivPixel(o.getNorthEast()),southWest:t.fromLatLngToDivPixel(o.getSouthWest())}),W=(o,t)=>{let{northEast:e,southWest:r}=o;return e.x+=t,e.y-=t,r.x-=t,r.y+=t,{northEast:e,southWest:r}},q=(o,t)=>{let{northEast:e,southWest:r}=o;const s=t.fromDivPixelToLatLng(r),n=t.fromDivPixelToLatLng(e);return new google.maps.LatLngBounds(s,n)};class I{constructor(t){let{maxZoom:e=16}=t;this.maxZoom=e}noop(t){let{markers:e}=t;return K(e)}}class U extends I{constructor(t){var{viewportPadding:e=60}=t;super(C(t,["viewportPadding"])),this.viewportPadding=60,this.viewportPadding=e}calculate(t){let{markers:e,map:r,mapCanvasProjection:s}=t;return r.getZoom()>=this.maxZoom?{clusters:this.noop({markers:e}),changed:!1}:{clusters:this.cluster({markers:S(r,s,e,this.viewportPadding),map:r,mapCanvasProjection:s})}}}const K=o=>o.map(t=>new P({position:f.getPosition(t),markers:[t]}));function pt(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var mt=function o(t,e){if(t===e)return!0;if(t&&e&&typeof t=="object"&&typeof e=="object"){if(t.constructor!==e.constructor)return!1;var r,s,n;if(Array.isArray(t)){if((r=t.length)!=e.length)return!1;for(s=r;s--!=0;)if(!o(t[s],e[s]))return!1;return!0}if(t.constructor===RegExp)return t.source===e.source&&t.flags===e.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===e.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===e.toString();if((r=(n=Object.keys(t)).length)!==Object.keys(e).length)return!1;for(s=r;s--!=0;)if(!Object.prototype.hasOwnProperty.call(e,n[s]))return!1;for(s=r;s--!=0;){var a=n[s];if(!o(t[a],e[a]))return!1}return!0}return t!=t&&e!=e},b=pt(mt);const J=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class B{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,r]=new Uint8Array(t,0,2);if(e!==219)throw new Error("Data does not appear to be in a KDBush format.");const s=r>>4;if(s!==1)throw new Error(`Got v${s} data when expected v1.`);const n=J[15&r];if(!n)throw new Error("Unrecognized array type.");const[a]=new Uint16Array(t,2,1),[h]=new Uint32Array(t,4,1);return new B(h,a,n,t)}constructor(t,e=64,r=Float64Array,s){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=r,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const n=J.indexOf(this.ArrayType),a=2*t*this.ArrayType.BYTES_PER_ELEMENT,h=t*this.IndexArrayType.BYTES_PER_ELEMENT,i=(8-h%8)%8;if(n<0)throw new Error(`Unexpected typed array class: ${r}.`);s&&s instanceof ArrayBuffer?(this.data=s,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+h+i,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+a+h+i),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+h+i,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+n]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t)}add(t,e){const r=this._pos>>1;return this.ids[r]=r,this.coords[this._pos++]=t,this.coords[this._pos++]=e,r}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return D(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,r,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:n,coords:a,nodeSize:h}=this,i=[0,n.length-1,0],c=[];for(;i.length;){const u=i.pop()||0,l=i.pop()||0,p=i.pop()||0;if(l-p<=h){for(let g=p;g<=l;g++){const k=a[2*g],x=a[2*g+1];k>=t&&k<=r&&x>=e&&x<=s&&c.push(n[g])}continue}const d=p+l>>1,w=a[2*d],y=a[2*d+1];w>=t&&w<=r&&y>=e&&y<=s&&c.push(n[d]),(u===0?t<=w:e<=y)&&(i.push(p),i.push(d-1),i.push(1-u)),(u===0?r>=w:s>=y)&&(i.push(d+1),i.push(l),i.push(1-u))}return c}within(t,e,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:s,coords:n,nodeSize:a}=this,h=[0,s.length-1,0],i=[],c=r*r;for(;h.length;){const u=h.pop()||0,l=h.pop()||0,p=h.pop()||0;if(l-p<=a){for(let g=p;g<=l;g++)Y(n[2*g],n[2*g+1],t,e)<=c&&i.push(s[g]);continue}const d=p+l>>1,w=n[2*d],y=n[2*d+1];Y(w,y,t,e)<=c&&i.push(s[d]),(u===0?t-r<=w:e-r<=y)&&(h.push(p),h.push(d-1),h.push(1-u)),(u===0?t+r>=w:e+r>=y)&&(h.push(d+1),h.push(l),h.push(1-u))}return i}}function D(o,t,e,r,s,n){if(s-r<=e)return;const a=r+s>>1;X(o,t,a,r,s,n),D(o,t,e,r,a-1,1-n),D(o,t,e,a+1,s,1-n)}function X(o,t,e,r,s,n){for(;s>r;){if(s-r>600){const c=s-r+1,u=e-r+1,l=Math.log(c),p=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*p*(c-p)/c)*(u-c/2<0?-1:1);X(o,t,e,Math.max(r,Math.floor(e-u*p/c+d)),Math.min(s,Math.floor(e+(c-u)*p/c+d)),n)}const a=t[2*e+n];let h=r,i=s;for(L(o,t,r,e),t[2*s+n]>a&&L(o,t,r,s);h<i;){for(L(o,t,h,i),h++,i--;t[2*h+n]<a;)h++;for(;t[2*i+n]>a;)i--}t[2*r+n]===a?L(o,t,r,i):(i++,L(o,t,i,s)),i<=e&&(r=i+1),e<=i&&(s=i-1)}}function L(o,t,e,r){N(o,e,r),N(t,2*e,2*r),N(t,2*e+1,2*r+1)}function N(o,t,e){const r=o[t];o[t]=o[e],o[e]=r}function Y(o,t,e,r){const s=o-e,n=t-r;return s*s+n*n}const dt={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:o=>o},H=Math.fround||(F=new Float32Array(1),o=>(F[0]=+o,F[0]));var F;const v=3,M=5,Q=6;class tt{constructor(t){this.options=Object.assign(Object.create(dt),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:r,maxZoom:s}=this.options;e&&console.time("total time");const n=`prepare ${t.length} points`;e&&console.time(n),this.points=t;const a=[];for(let i=0;i<t.length;i++){const c=t[i];if(!c.geometry)continue;const[u,l]=c.geometry.coordinates,p=H(T(u)),d=H(j(l));a.push(p,d,1/0,i,-1,1),this.options.reduce&&a.push(0)}let h=this.trees[s+1]=this._createTree(a);e&&console.timeEnd(n);for(let i=s;i>=r;i--){const c=+Date.now();h=this.trees[i]=this._createTree(this._cluster(h,i)),e&&console.log("z%d: %d clusters in %dms",i,h.numItems,+Date.now()-c)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let r=((t[0]+180)%360+360)%360-180;const s=Math.max(-90,Math.min(90,t[1]));let n=t[2]===180?180:((t[2]+180)%360+360)%360-180;const a=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)r=-180,n=180;else if(r>n){const l=this.getClusters([r,s,180,a],e),p=this.getClusters([-180,s,n,a],e);return l.concat(p)}const h=this.trees[this._limitZoom(e)],i=h.range(T(r),j(a),T(n),j(s)),c=h.data,u=[];for(const l of i){const p=this.stride*l;u.push(c[p+M]>1?et(c,p,this.clusterProps):this.points[c[p+v]])}return u}getChildren(t){const e=this._getOriginId(t),r=this._getOriginZoom(t),s="No cluster with the specified id.",n=this.trees[r];if(!n)throw new Error(s);const a=n.data;if(e*this.stride>=a.length)throw new Error(s);const h=this.options.radius/(this.options.extent*Math.pow(2,r-1)),i=a[e*this.stride],c=a[e*this.stride+1],u=n.within(i,c,h),l=[];for(const p of u){const d=p*this.stride;a[d+4]===t&&l.push(a[d+M]>1?et(a,d,this.clusterProps):this.points[a[d+v]])}if(l.length===0)throw new Error(s);return l}getLeaves(t,e,r){e=e||10,r=r||0;const s=[];return this._appendLeaves(s,t,e,r,0),s}getTile(t,e,r){const s=this.trees[this._limitZoom(t)],n=Math.pow(2,t),{extent:a,radius:h}=this.options,i=h/a,c=(r-i)/n,u=(r+1+i)/n,l={features:[]};return this._addTileFeatures(s.range((e-i)/n,c,(e+1+i)/n,u),s.data,e,r,n,l),e===0&&this._addTileFeatures(s.range(1-i/n,c,1,u),s.data,n,r,n,l),e===n-1&&this._addTileFeatures(s.range(0,c,i/n,u),s.data,-1,r,n,l),l.features.length?l:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const r=this.getChildren(t);if(e++,r.length!==1)break;t=r[0].properties.cluster_id}return e}_appendLeaves(t,e,r,s,n){const a=this.getChildren(e);for(const h of a){const i=h.properties;if(i&&i.cluster?n+i.point_count<=s?n+=i.point_count:n=this._appendLeaves(t,i.cluster_id,r,s,n):n<s?n++:t.push(h),t.length===r)break}return n}_createTree(t){const e=new B(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let r=0;r<t.length;r+=this.stride)e.add(t[r],t[r+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,e,r,s,n,a){for(const h of t){const i=h*this.stride,c=e[i+M]>1;let u,l,p;if(c)u=rt(e,i,this.clusterProps),l=e[i],p=e[i+1];else{const y=this.points[e[i+v]];u=y.properties;const[g,k]=y.geometry.coordinates;l=T(g),p=j(k)}const d={type:1,geometry:[[Math.round(this.options.extent*(l*n-r)),Math.round(this.options.extent*(p*n-s))]],tags:u};let w;w=c||this.options.generateId?e[i+v]:this.points[e[i+v]].id,w!==void 0&&(d.id=w),a.features.push(d)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:r,extent:s,reduce:n,minPoints:a}=this.options,h=r/(s*Math.pow(2,e)),i=t.data,c=[],u=this.stride;for(let l=0;l<i.length;l+=u){if(i[l+2]<=e)continue;i[l+2]=e;const p=i[l],d=i[l+1],w=t.within(i[l],i[l+1],h),y=i[l+M];let g=y;for(const k of w){const x=k*u;i[x+2]>e&&(g+=i[x+M])}if(g>y&&g>=a){let k,x=p*y,A=d*y,at=-1;const V=((l/u|0)<<5)+(e+1)+this.points.length;for(const ft of w){const _=ft*u;if(i[_+2]<=e)continue;i[_+2]=e;const ht=i[_+M];x+=i[_]*ht,A+=i[_+1]*ht,i[_+4]=V,n&&(k||(k=this._map(i,l,!0),at=this.clusterProps.length,this.clusterProps.push(k)),n(k,this._map(i,_)))}i[l+4]=V,c.push(x/g,A/g,1/0,V,-1,g),n&&c.push(at)}else{for(let k=0;k<u;k++)c.push(i[l+k]);if(g>1)for(const k of w){const x=k*u;if(!(i[x+2]<=e)){i[x+2]=e;for(let A=0;A<u;A++)c.push(i[x+A])}}}}return c}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,r){if(t[e+M]>1){const a=this.clusterProps[t[e+Q]];return r?Object.assign({},a):a}const s=this.points[t[e+v]].properties,n=this.options.map(s);return r&&n===s?Object.assign({},n):n}}function et(o,t,e){return{type:"Feature",id:o[t+v],properties:rt(o,t,e),geometry:{type:"Point",coordinates:[(r=o[t],360*(r-.5)),gt(o[t+1])]}};var r}function rt(o,t,e){const r=o[t+M],s=r>=1e4?`${Math.round(r/1e3)}k`:r>=1e3?Math.round(r/100)/10+"k":r,n=o[t+Q],a=n===-1?{}:Object.assign({},e[n]);return Object.assign(a,{cluster:!0,cluster_id:o[t+v],point_count:r,point_count_abbreviated:s})}function T(o){return o/360+.5}function j(o){const t=Math.sin(o*Math.PI/180),e=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return e<0?0:e>1?1:e}function gt(o){const t=(180-360*o)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}class st extends I{constructor(t){var{maxZoom:e,radius:r=60}=t,s=C(t,["maxZoom","radius"]);super({maxZoom:e}),this.state={zoom:-1},this.superCluster=new tt(Object.assign({maxZoom:this.maxZoom,radius:r},s))}calculate(t){let e=!1;const r={zoom:t.map.getZoom()};if(!b(t.markers,this.markers)){e=!0,this.markers=[...t.markers];const s=this.markers.map(n=>{const a=f.getPosition(n);return{type:"Feature",geometry:{type:"Point",coordinates:[a.lng(),a.lat()]},properties:{marker:n}}});this.superCluster.load(s)}return e||(this.state.zoom<=this.maxZoom||r.zoom<=this.maxZoom)&&(e=!b(this.state,r)),this.state=r,e&&(this.clusters=this.cluster(t)),{clusters:this.clusters,changed:e}}cluster(t){let{map:e}=t;return this.superCluster.getClusters([-180,-90,180,90],Math.round(e.getZoom())).map(r=>this.transformCluster(r))}transformCluster(t){let{geometry:{coordinates:[e,r]},properties:s}=t;if(s.cluster)return new P({markers:this.superCluster.getLeaves(s.cluster_id,1/0).map(a=>a.properties.marker),position:{lat:r,lng:e}});const n=s.marker;return new P({markers:[n],position:f.getPosition(n)})}}class ot{constructor(t,e){this.markers={sum:t.length};const r=e.map(n=>n.count),s=r.reduce((n,a)=>n+a,0);this.clusters={count:e.length,markers:{mean:s/e.length,sum:s,min:Math.min(...r),max:Math.max(...r)}}}}class nt{render(t,e,r){let{count:s,position:n}=t;const a=`<svg fill="${s>Math.max(10,e.clusters.markers.mean)?"#ff0000":"#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${s}</text>
</svg>`,h=`Cluster of ${s} markers`,i=Number(google.maps.Marker.MAX_ZINDEX)+s;if(f.isAdvancedMarkerAvailable(r)){const u=new DOMParser().parseFromString(a,"image/svg+xml").documentElement;u.setAttribute("transform","translate(0 25)");const l={map:r,position:n,zIndex:i,title:h,content:u};return new google.maps.marker.AdvancedMarkerElement(l)}const c={position:n,zIndex:i,title:h,icon:{url:`data:image/svg+xml;base64,${btoa(a)}`,anchor:new google.maps.Point(25,25)}};return new google.maps.Marker(c)}}class ${constructor(){(function(t,e){for(let r in e.prototype)t.prototype[r]=e.prototype[r]})($,google.maps.OverlayView)}}var R;m.MarkerClustererEvents=void 0,(R=m.MarkerClustererEvents||(m.MarkerClustererEvents={})).CLUSTERING_BEGIN="clusteringbegin",R.CLUSTERING_END="clusteringend",R.CLUSTER_CLICK="click";const it=(o,t,e)=>{e.fitBounds(t.bounds)};m.AbstractAlgorithm=I,m.AbstractViewportAlgorithm=U,m.Cluster=P,m.ClusterStats=ot,m.DefaultRenderer=nt,m.GridAlgorithm=class extends U{constructor(o){var{maxDistance:t=4e4,gridSize:e=40}=o;super(C(o,["maxDistance","gridSize"])),this.clusters=[],this.state={zoom:-1},this.maxDistance=t,this.gridSize=e}calculate(o){let{markers:t,map:e,mapCanvasProjection:r}=o;const s={zoom:e.getZoom()};let n=!1;return this.state.zoom>=this.maxZoom&&s.zoom>=this.maxZoom||(n=!b(this.state,s)),this.state=s,e.getZoom()>=this.maxZoom?{clusters:this.noop({markers:t}),changed:n}:{clusters:this.cluster({markers:S(e,r,t,this.viewportPadding),map:e,mapCanvasProjection:r})}}cluster(o){let{markers:t,map:e,mapCanvasProjection:r}=o;return this.clusters=[],t.forEach(s=>{this.addToClosestCluster(s,e,r)}),this.clusters}addToClosestCluster(o,t,e){let r=this.maxDistance,s=null;for(let n=0;n<this.clusters.length;n++){const a=this.clusters[n],h=G(a.bounds.getCenter().toJSON(),f.getPosition(o).toJSON());h<r&&(r=h,s=a)}if(s&&Z(s.bounds,e,this.gridSize).contains(f.getPosition(o)))s.push(o);else{const n=new P({markers:[o]});this.clusters.push(n)}}},m.MarkerClusterer=class extends ${constructor(o){let{map:t,markers:e=[],algorithmOptions:r={},algorithm:s=new st(r),renderer:n=new nt,onClusterClick:a=it}=o;super(),this.markers=[...e],this.clusters=[],this.algorithm=s,this.renderer=n,this.onClusterClick=a,t&&this.setMap(t)}addMarker(o,t){this.markers.includes(o)||(this.markers.push(o),t||this.render())}addMarkers(o,t){o.forEach(e=>{this.addMarker(e,!0)}),t||this.render()}removeMarker(o,t){const e=this.markers.indexOf(o);return e!==-1&&(f.setMap(o,null),this.markers.splice(e,1),t||this.render(),!0)}removeMarkers(o,t){let e=!1;return o.forEach(r=>{e=this.removeMarker(r,!0)||e}),e&&!t&&this.render(),e}clearMarkers(o){this.markers.length=0,o||this.render()}render(){const o=this.getMap();if(o instanceof google.maps.Map&&o.getProjection()){google.maps.event.trigger(this,m.MarkerClustererEvents.CLUSTERING_BEGIN,this);const{clusters:t,changed:e}=this.algorithm.calculate({markers:this.markers,map:o,mapCanvasProjection:this.getProjection()});if(e||e==null){const r=new Set;for(const n of t)n.markers.length==1&&r.add(n.markers[0]);const s=[];for(const n of this.clusters)n.marker!=null&&(n.markers.length==1?r.has(n.marker)||f.setMap(n.marker,null):s.push(n.marker));this.clusters=t,this.renderClusters(),requestAnimationFrame(()=>s.forEach(n=>f.setMap(n,null)))}google.maps.event.trigger(this,m.MarkerClustererEvents.CLUSTERING_END,this)}}onAdd(){this.idleListener=this.getMap().addListener("idle",this.render.bind(this)),this.render()}onRemove(){google.maps.event.removeListener(this.idleListener),this.reset()}reset(){this.markers.forEach(o=>f.setMap(o,null)),this.clusters.forEach(o=>o.delete()),this.clusters=[]}renderClusters(){const o=new ot(this.markers,this.clusters),t=this.getMap();this.clusters.forEach(e=>{e.markers.length===1?e.marker=e.markers[0]:(e.marker=this.renderer.render(e,o,t),e.markers.forEach(r=>f.setMap(r,null)),this.onClusterClick&&e.marker.addListener("click",r=>{google.maps.event.trigger(this,m.MarkerClustererEvents.CLUSTER_CLICK,e),this.onClusterClick(r,e,t)})),f.setMap(e.marker,t)})}},m.MarkerUtils=f,m.NoopAlgorithm=class extends I{constructor(o){super(C(o,[]))}calculate(o){let{markers:t,map:e,mapCanvasProjection:r}=o;return{clusters:this.cluster({markers:t,map:e,mapCanvasProjection:r}),changed:!1}}cluster(o){return this.noop(o)}},m.SuperClusterAlgorithm=st,m.SuperClusterViewportAlgorithm=class extends U{constructor(o){var{maxZoom:t,radius:e=60,viewportPadding:r=60}=o,s=C(o,["maxZoom","radius","viewportPadding"]);super({maxZoom:t,viewportPadding:r}),this.superCluster=new tt(Object.assign({maxZoom:this.maxZoom,radius:e},s)),this.state={zoom:-1,view:[0,0,0,0]}}calculate(o){const t={zoom:Math.round(o.map.getZoom()),view:z(o.map.getBounds(),o.mapCanvasProjection,this.viewportPadding)};let e=!b(this.state,t);if(!b(o.markers,this.markers)){e=!0,this.markers=[...o.markers];const r=this.markers.map(s=>{const n=f.getPosition(s);return{type:"Feature",geometry:{type:"Point",coordinates:[n.lng(),n.lat()]},properties:{marker:s}}});this.superCluster.load(r)}return e&&(this.clusters=this.cluster(o),this.state=t),{clusters:this.clusters,changed:e}}cluster(o){let{map:t,mapCanvasProjection:e}=o;const r={zoom:Math.round(t.getZoom()),view:z(t.getBounds(),e,this.viewportPadding)};return this.superCluster.getClusters(r.view,r.zoom).map(s=>this.transformCluster(s))}transformCluster(o){let{geometry:{coordinates:[t,e]},properties:r}=o;if(r.cluster)return new P({markers:this.superCluster.getLeaves(r.cluster_id,1/0).map(n=>n.properties.marker),position:{lat:e,lng:t}});const s=r.marker;return new P({markers:[s],position:f.getPosition(s)})}},m.defaultOnClusterClickHandler=it,m.distanceBetweenPoints=G,m.extendBoundsToPaddedViewport=Z,m.extendPixelBounds=W,m.filterMarkersToPaddedViewport=S,m.getPaddedViewport=z,m.noop=K,m.pixelBoundsToLatLngBounds=q,Object.defineProperty(m,"__esModule",{value:!0})})}(O,O.exports)),O.exports}var xt=yt(),vt=kt(xt);export{vt as default};
